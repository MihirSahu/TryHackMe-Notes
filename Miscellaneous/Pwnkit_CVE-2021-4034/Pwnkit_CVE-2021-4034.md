# Pwnkit: CVE-2021-4034


## Introduction and Deploy
- Pwnkit: CVE-2021-4034 is a Local Privilege Escalation vulnerability located in the `Polkit` package, which is installed by default in almost every major linux distro

## Background
- [Security Advisory](https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt)
- The vulnerability exists in every version of Polkit (Policy Toolkit) since it was released in 2009
- The vulnerability is a local privilege escalation vulnerability, so it can't be exploited remotely
- Polkit is a part of the linux authorization system
    - Helps determine whether you have requisite permissions
    - Integrated with systemd and is more configurable than sudo, called the `sudo of systemd`
- The `pkexec` utility is what contains the pwnkit vulnerability, and is the primary front-end for polkit
    - Ex. `pkexec useradd test1234`
        - Shows a pop-up in GUI, and something like this in CLI
```
muiri@demo-vm:~$ pkexec useradd test1234
==== AUTHENTICATING FOR org.freedesktop.policykit.exec ===
Authentication is needed to run '/usr/sbin/useradd' as the super user
Authenticating as: muiri,,, (muiri)
Password:
```
```
As mentioned previously, the Pwnkit vulnerability exists in the pkexec utility — the primary front-end to the Polkit system. We won't go into too much detail here in the interests of readability; however, you are encouraged to read through the Qualys Security Advisory for a full technical explanation of the vulnerability.

The short version is this: versions of pkexec released prior to the patch don't handle command-line arguments safely, which leads to an "out-of-bounds write" vulnerability, allowing an attacker to manipulate the environment with which pkexec is run. This is all you really need to know, but for a slightly more technical explanation, read on!

More specifically, pkexec attempts to parse any command-line arguments that we pass it using a for-loop, starting at an index of 1 to offset the name of the program and obtain the first real argument (e.g. if we entered pkexec bash, then as pkexec is the name of the program, it would be argument 0 — the actual command-line arguments start at index 1). The name of the program is irrelevant to argument parsing, so the indexing is simply offset to ignore it.

What happens, then, if we don't provide any arguments? The index is set permanently to 1!

The following pseudocode may help you to visualise this:

Pseudocode: List Indexing Starting at 1
for(n=1; n < number_of_arguments; n++){
  //Do Stuff
}
If the number of arguments is 0 then n is never less than the number of arguments. As such, n stays equal to one and the loop is bypassed completely.

This becomes a problem later when pkexec attempts to write to the value of the argument at index n. As there are no command-line arguments, there is no argument at index n — instead the program overwrites the next thing in memory, which just so happens to be the first value in the list of environment variables when the program is called using a C function called execve(). In other words, by passing pkexec a null list of arguments, we can force it to overwrite an environment variable instead!

For context: certain "dangerous" environment variables are removed by the operating system when you attempt to run a program that has the SUID bit set (as pkexec does by necessity); this is to prevent attackers from being able to hijack the program as it runs with administrative permissions. Using the out-of-bounds write, we are able to re-introduce our choice of these dangerous environment variables by tricking pkexec into adding it for  us. There are a variety of different ways to abuse this, all leading to code execution as the root user.
```

## Exploitation
- Exploiting it is easy
- [One exploit](https://github.com/arthepsy/CVE-2021-4034)
    - This uses the `GCONV_PATH` variable to include a malicious shared object file that calls `/bin/sh` with root permissions

## Remediations
- Most developers have already patched the vulnerability, so just update
- To do it manually, remove the SUID bit from the `pkexec` binary with `sudo chmod 0755 which pkexec`

## Creating Your Own Vulnerable Machine
- I used Ubuntu Server for this
1. Download and install ubuntu
2. Go to the [policykit packages](https://launchpad.net/ubuntu/+source/policykit-1/) and find the old vulnerable package version for your edition of Ubuntu
3. Install aptitude so you don't have to downgrade dependencies manually `sudo apt-get install aptitude`
4. Use `sudo aptitude install policykit-1=<version of vulnerable package>`, then follow the guide to downgrade the package and dependencies
5. Now download the exploit from github, compile it, and run :)
